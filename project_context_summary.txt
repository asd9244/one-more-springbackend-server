
================================================================================
 FILE: backend-spring\.env
================================================================================

# Server Configuration
APP_ENV=prod

# Database (PostgreSQL)
DB_HOST=localhost
DB_USER=postgres
DB_PW=1234
# test

# External AI Server (FastAPI - 영수증/이미지 분석)
# 로컬 테스트 시에는 아래 주소 사용, 배포 시에는 외부 터널 주소 변경.
AI_SERVER_URL=http://localhost:8000

# Ollama Base URL (Spring AI용)
# 로컬 테스트 시에는 아래 주소 사용, 배포 시에는 외부 터널 주소 변경.
OLLAMA_URL=http://localhost:11434

# 전체 데이터 임베딩하는 API 암호화용.
ADMIN_SECRET_KEY=/vectors

================================================================================
 FILE: backend-spring\build.gradle
================================================================================

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.1'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.board'
version = '0.0.1-SNAPSHOT'
description = 'backend-spring'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spring.io/milestone' } // Spring AI 마일스톤 저장소
}

ext {
    set('springAiVersion', "1.0.0-M4") // Spring AI 버전 관리 (BOM)
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.7.0'

    // NoSuchMethodError 방지를 위해 Swagger 관련 라이브러리 버전 강제 고정
    // Spring AI가 하위 버전을 가져오는 것을 방지하기 위해 2.2.25로 명시함
    implementation 'io.swagger.core.v3:swagger-annotations:2.2.25'
    implementation 'io.swagger.core.v3:swagger-models:2.2.25'

    implementation 'io.projectreactor:reactor-core'
    implementation 'org.postgresql:postgresql'

    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation 'org.springframework.ai:spring-ai-ollama-spring-boot-starter' // Spring AI Ollama 스타터
    // Java와 Kotlin에서 .env 파일을 쉽게 로드하여 환경 변수처럼 사용할 수 있게 해주는 오픈소스 라이브러리
    implementation 'me.paulschwarz:springboot3-dotenv:5.0.1'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.ai:spring-ai-bom:${springAiVersion}"
    }
}

test {
    useJUnitPlatform()
}

================================================================================
 FILE: backend-spring\README.md
================================================================================

# Project Context
- 프로젝트의 흐름
1. 사용자에게 web페이지에서 입력을 받는다. (이 입력은 사용자의 입력 텍스트들, 선택한 항목의 텍스트들, 촬영한 이미지, 촬영한 영수증이 될 수 있다.)
2. spring backend에서 입력을 받고, 이미지인지 텍스트인지 분류하고, python 서버로 분석을 위해 전송한다. 
3. python 서버는 전달받은 데이터가 
3-1 이미지일 경우, YOLO8을 모델을 통해 이미지 속 객체를 텍스트로 변환 후 LLM으로 전달한다.
3-2 영수증일 경우, OCR 모델을 통해 영수증 속 텍스트 객체를 텍스트로 변환 후 LLM으로 전달한다.
3-3 텍스트일 경우 LLM으로 전달한다.
4. LLM은 전달받은 텍스트를 작성된 prompt에 넣어서 정해진 형식의 레시피를 출력한다. 
5. LLM이 출력한 레시피를 파이선 서버에서 스프링서버로 전송한다. 
6. 전달받은 레시피를 사용자에게 전달한다. 

# Project properties 
1. 초반 단계에서는 DB를 만들지 않고, 서버간의 데이터 전송만으로 기능을 구현하고 있다. 
2. 기술스택은 대략적인 예정이고. 아직 완벽하게 사용중이지 않다. 만약 사용하고 싶은지 확인하고 싶다면, 직접 사용여부를 물어봐라.

# Detailed Technical Stack
## 1. Main Backend (Java)
- Framework: Spring Boot 4.0.1 (Java 17)
- ORM/DB: Spring Data JPA, QueryDSL (동적 필터링용), PostgreSQL + PostGIS (공간 데이터 연산)
- Security: Spring Security + JWT (Stateless)
- Infrastructure: Redis (할인 정보 캐싱), JUnit5 (테스트)

## 2. AI Service (Python)
- Framework: FastAPI (Asynchronous)
- Vision: YOLOv8 (식재료 객체 탐지), Google Cloud Vision API (영수증 OCR)
- Image Processing: OpenCV (전처리 및 신선도 분석)
- Deployment: Docker (AI 환경 격리)

## 3. Intelligence Layer (LLM)
- Model: OpenAI GPT-4o (또는 Claude 3.5)
- Library: LangChain (프롬프트 템플릿 및 체인 관리)
- Core: 자연어 기반 맥락 분석 및 영양 정보 리포트 요약


Get-ChildItem -Recurse -Include *.java, *.properties, *.yml, *.gradle, *.xml | ForEach-Object {
    "--- FILE: $($_.FullName) ---"
    Get-Content $_.FullName
    "`n"
} | Out-File -FilePath project_context.txt -Encoding utf8NoBOM


일단 코드를 추가해야돼. 기존 코드도 약간 다듬어야하고. 
지금 컨트롤러에서 이미지만 업로드한다고 메서드가 되어있는데. 
영수증 or 재료사진 둘 중 하나를 받는거라서. 파이썬 서버에서 영수증은 OCR이 분석하고, 재료사진은 yolo가 분석해야하거든.
백엔드에서 구분해서 보내줘야 파이썬에서 알맞은 모델에 전달할 수 있어.
dto, service, controller 수정해서 코드 보내줘. (수정할 필요 없으면 안건드려도 괜찮아.)


================================================================================
 FILE: backend-spring\settings.gradle
================================================================================

rootProject.name = 'backend-spring'


================================================================================
 FILE: backend-spring\config\SwaggerConfig.java
================================================================================

package com.board.one_more_project.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * [Swagger 설정 클래스]
 * @Configuration: 이 클래스가 스프링의 설정 파일임을 알려줍니다.
 */
@Configuration
public class SwaggerConfig {

    /**
     * OpenAPI 객체를 스프링 빈(Bean)으로 등록합니다.
     * 이 설정이 있어야 Swagger UI에서 우리 프로젝트의 정보를 예쁘게 보여줍니다.
     */
    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("One More Project - AI 레시피 서비스 API") // 문서 제목
                        .description("사용자의 식재료 사진이나 영수증을 분석하여 AI 레시피를 제공하는 서비스의 API 문서입니다.") // 상세 설명
                        .version("1.0.0")); // API 버전
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\backendSpringApplication.java
================================================================================

package com.board.one_more_project;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class backendSpringApplication {

    public static void main(String[] args) {
        SpringApplication.run(backendSpringApplication.class, args);
        System.out.println("hello word");
    }
}


================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\IngredientController.java
================================================================================

package com.board.one_more_project.domain.ingredient;

import com.board.one_more_project.domain.ingredient.dto.IngredientResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@Tag(name = "Master Data", description = "취향, 재료, 조미료 등 마스터 데이터 조회") // Swagger 그룹 이름
@Slf4j
@RestController // JSON 데이터를 반환하는 컨트롤러임을 선언
@RequestMapping("/api/ingredients")
@RequiredArgsConstructor
// frontend의 HTTP request를 받는 API Endpoint
public class IngredientController {

    private final IngredientService ingredientService; // 서비스(주방) 연결

    @Operation(summary = "재료 목록 조회", description = "모든 재료(Ingredients) 목록을 카테고리 순으로 반환합니다.")
    @GetMapping // GET 요청을 처리합니다.
    public ResponseEntity<List<IngredientResponse>> getAllIngredients() {
        log.info("GET /api/ingredients 요청 수신");

        // 1. 서비스에게 일을 시키고 결과를 받습니다.
        List<IngredientResponse> ingredients = ingredientService.getAllIngredients();

        log.info("재료 데이터 {}개 조회 완료", ingredients.size());

        // 2. 결과(DTO 리스트)를 200 OK 신호와 함께 반환합니다.
        return ResponseEntity.ok(ingredients);
    }

    @Operation(summary = "재료 검색 (AI 유사도 기반)", description = "입력한 키워드와 의미적으로 가장 유사한 재료 10개를 반환합니다.")
    @GetMapping("/search")
    public ResponseEntity<List<IngredientResponse>> searchIngredients(@RequestParam("q") String keyword) {
        log.info("GET /api/ingredients/search?q={} 요청 수신", keyword);

        List<IngredientResponse> results = ingredientService.searchIngredients(keyword);

        return ResponseEntity.ok(results);
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\IngredientDto.java
================================================================================

package com.board.one_more_project.domain.ingredient;

import io.swagger.v3.oas.annotations.media.Schema;

@Schema(description = "재료 정보 (이름 + 수량)")
// python fast API 서버로 보낼 재료의 이름+수량 데이터를 합치는 역할.
public record IngredientDto(
        @Schema(description = "재료 이름", example = "돼지고기")
        String ingredient,

        @Schema(description = "재료 수량 (단위 포함)", example = "200g")
        String quantity
) {}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\IngredientRepository.java
================================================================================

package com.board.one_more_project.domain.ingredient;

import com.board.one_more_project.domain.ingredient.dto.Ingredient;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

// DB에 직접 접근해서 데이터를 CRUD하는 Dtat Access Layer(데이터 접근 계층).
public interface IngredientRepository extends JpaRepository<Ingredient, Long> {
    // JPA 활용 쿼리
    List<Ingredient> findAllByOrderByNameAsc();

    // 반환 타입을 int로 변경하고 clearAutomatically 추가하여 PSQLException 방지
    @Modifying(clearAutomatically = true)
    @Transactional
    @Query(value = "UPDATE ingredients SET embedding = cast(:embedding as vector) WHERE id = :id", nativeQuery = true)
    int updateEmbedding(@Param("id") Long id, @Param("embedding") String embedding);

    @Query(value = "SELECT * FROM ingredients " +
            "ORDER BY embedding <=> cast(:queryVector as vector) " +
            "LIMIT :limit", nativeQuery = true)
    List<Ingredient> findNearestIngredients(@Param("queryVector") String queryVector, @Param("limit") int limit);
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\IngredientService.java
================================================================================

package com.board.one_more_project.domain.ingredient;

import com.board.one_more_project.domain.ingredient.dto.IngredientResponse;

import java.util.List;

// 비즈니스 로직의 수행 방법을 정의한 추상화 interface
public interface IngredientService {

    List<IngredientResponse> getAllIngredients();

    List<IngredientResponse> searchIngredients(String keyword);

}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\IngredientServiceImpl.java
================================================================================

package com.board.one_more_project.domain.ingredient;

import com.board.one_more_project.domain.ingredient.dto.Ingredient;
import com.board.one_more_project.domain.ingredient.dto.IngredientResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.embedding.EmbeddingModel; // Spring AI 표준 인터페이스
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
// 비즈니스 로직 실제 구현 계층(business Logic Layer)
public class IngredientServiceImpl implements IngredientService {

    private final IngredientRepository ingredientRepository;
    private final EmbeddingModel embeddingModel; // Ollama 구현체가 자동으로 주입됨

    @Override
    public List<IngredientResponse> getAllIngredients() {
        return ingredientRepository.findAllByOrderByNameAsc()
                .stream()
                .map(IngredientResponse::from)
                .toList();
    }

    @Override
    public List<IngredientResponse> searchIngredients(String keyword) {
        log.info("Ollama 기반 의미론적 검색 시작: {}", keyword);

        // 1. Spring AI를 이용한 로컬 임베딩 생성
        // embed() 메서드는 내부적으로 Ollama API를 호출하여 float[]를 반환함
        float[] vector = embeddingModel.embed(keyword);

        // 2. pgvector 검색을 위해 배열을 문자열 포맷으로 변환
        String vectorString = Arrays.toString(vector);

        // 3. Repository의 Native Query 호출
        List<Ingredient> results = ingredientRepository.findNearestIngredients(vectorString, 10);

        return results.stream()
                .map(IngredientResponse::from)
                .toList();
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\dto\Ingredient.java
================================================================================

package com.board.one_more_project.domain.ingredient.dto;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import java.time.OffsetDateTime;

@Entity // DB 테이블과 연결됨
@Table(name = "ingredients") // 'ingredients' 테이블과 매핑됨
@Getter
@NoArgsConstructor
// ORM(Object-Relational Mapping): 클레스를 DB테이블로 매핑한다. JPA가 이 객체를 보고 DB쿼리를 자동 생성함.
public class Ingredient {

    @Id // PK (Primary Key) 설정
    @GeneratedValue(strategy = GenerationType.IDENTITY) // SERIAL (Auto Increment)
    private Long id;

    @Column(nullable = false, unique = true) // NULL 불가, 중복 불가
    private String name; // 재료 이름 (예: 돼지고기, 양파)

    @Column(name = "created_at")
    private OffsetDateTime createdAt;

    // 데이터가 저장되기 전에 실행되는 로직
    @PrePersist
    public void onPrePersist() {
        this.createdAt = OffsetDateTime.now();
    }

}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\dto\IngredientAnalysisResponse.java
================================================================================

package com.board.one_more_project.domain.ingredient.dto;

import com.board.one_more_project.domain.ingredient.IngredientDto;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.List;

// 파이썬의 이미지 분석 결과(이미지 분석.txt) 구조에 맞춤. 기존의 단순 리스트에서 image_index를 포함한 구조로 변경.
@Schema(description = "AI 이미지 분석 결과 (개별 이미지)")
public record IngredientAnalysisResponse(
        @Schema(description = "이미지 번호 (0부터 시작)", example = "0")
        int image_index,

        @Schema(description = "분석된 재료 리스트")
        List<IngredientDto> ingredients
) {}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\ingredient\dto\IngredientResponse.java
================================================================================

package com.board.one_more_project.domain.ingredient.dto;

import io.swagger.v3.oas.annotations.media.Schema;

// 프론트엔드에서 사용자가 재료를 선택할 때 보여줄 리스트 아이템
@Schema(description = "재료 마스터 데이터 (카테고리 + 이름)")
public record IngredientResponse(
        @Schema(description = "재료 고유 ID", example = "1")
        Long id,

        @Schema(description = "재료 이름", example = "돼지고기")
        String name
) {
    // Entity -> DTO 변환 메서드 (정적 팩토리 메서드 패턴)
    public static IngredientResponse from(Ingredient entity) {
        return new IngredientResponse(
                entity.getId(),       // 나중에 프론트에서 ID로 제어할 수도 있어서 추가함
                entity.getName()
        );
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\Preference.java
================================================================================

package com.board.one_more_project.domain.preference;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import java.time.OffsetDateTime;

@Entity
@Table(name = "preferences") // 매핑될 DB 테이블 이름
@Getter
@NoArgsConstructor
public class Preference {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // SERIAL 타입 (DB에서 자동 생성)
    private Long id;

    @Column(nullable = false)
    private String category; // STYLE, TASTE, CONDITION

    @Column(nullable = false)
    private String name;

    @Column(name = "created_at")
    private OffsetDateTime createdAt;

    @PrePersist // 엔티티가 영속화(저장)되기 전에 실행되는 로직
    public void onPrePersist() {
        // DB의 TIMESTAMP WITH TIME ZONE 타입에 맞추기 위해 OffsetDateTime 사용
        this.createdAt = OffsetDateTime.now();
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\PreferenceController.java
================================================================================

package com.board.one_more_project.domain.preference;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.Parameter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Tag(name = "Master Data", description = "취향, 재료, 조미료 등 마스터 데이터 조회")
@Slf4j
@RestController
@RequestMapping("/api/preferences")
@RequiredArgsConstructor
public class PreferenceController {

    private final PreferenceService preferenceService;

    @Operation(summary = "취향 목록 조회", description = "모든 취향 목록을 반환합니다.")
    @GetMapping
    public ResponseEntity<List<PreferenceResponse>> getAllPreferences() {
        log.info("GET /api/preferences 요청 수신");
        return ResponseEntity.ok(preferenceService.getAllPreferences());
    }

    // 취향 분석 및 연관 키워드 추천
    @Operation(summary = "취향 분석 및 연관 키워드 추천", description = "유저가 선택한 취향 리스트를 받아, 어울리는 재료와 조미료를 추천합니다.")
    @PostMapping("/analyze")
    public ResponseEntity<PreferenceRecommendationResponse> analyzePreferences(
            @Parameter(description = "유저가 선택한 취향 키워드 리스트") @RequestBody List<String> preferences
    ) {
        log.info("POST /api/preferences/analyze 요청 수신: {}", preferences);
        PreferenceRecommendationResponse result = preferenceService.recommendRelatedKeywords(preferences);
        return ResponseEntity.ok(result);
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\PreferenceRecommendationResponse.java
================================================================================

package com.board.one_more_project.domain.preference;

import com.board.one_more_project.domain.ingredient.dto.IngredientResponse;
import com.board.one_more_project.domain.spice.SpiceResponse;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.List;

@Schema(description = "취향 기반 추천 키워드 (재료 + 조미료)")
public record PreferenceRecommendationResponse (
        @Schema(description = "입력한 취향과 어울리는 추천 재료 목록")
        List<IngredientResponse> ingredientResponseList,

        @Schema(description = "입력한 취향과 어울리는 추천 조미료 목록")
        List<SpiceResponse> spiceResponses

) {}






================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\PreferenceRepository.java
================================================================================

package com.board.one_more_project.domain.preference;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

public interface PreferenceRepository extends JpaRepository<Preference, Long> {

    List<Preference> findByCategoryOrderByIdAsc(String category);

    List<Preference> findAllByOrderByCategoryAscIdAsc();

    // 테이블명을 preferences로 정확히 수정 및 반환 타입 int 변경
    @Modifying(clearAutomatically = true)
    @Transactional
    @Query(value = "UPDATE preferences SET embedding = cast(:embedding as vector) WHERE id = :id", nativeQuery = true)
    int updateEmbedding(@Param("id") Long id, @Param("embedding") String embedding);
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\PreferenceResponse.java
================================================================================

package com.board.one_more_project.domain.preference;

import io.swagger.v3.oas.annotations.media.Schema;

/**
 * [API 응답 DTO]
 * 유저에게 제공할 취향 선택지 목록 (Preference Entity를 단순화)
 */
@Schema(description = "취향 선택지 응답 데이터 (카테고리 + 이름)")
public record PreferenceResponse(
        @Schema(description = "취향 카테고리 (STYLE, TASTE, CONDITION)", example = "STYLE")
        String category,

        @Schema(description = "취향 이름 (한식, 매운 맛, 해장용 등)", example = "한식")
        String name
) {
    /**
     * [변환 정적 팩토리 메서드]
     * DB Entity(Preference)를 응답 DTO(PreferenceResponse)로 변환하는 로직을 정의합니다.
     * Service 계층에서 이 메서드를 호출하여 Entity -> DTO 변환을 수행합니다.
     */
    public static PreferenceResponse from(Preference entity) {
        return new PreferenceResponse(
                entity.getCategory(),
                entity.getName()
        );
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\PreferenceService.java
================================================================================

package com.board.one_more_project.domain.preference;

import java.util.List;

// 유저의 취향 선택지(Preference) 데이터를 조회하는 비즈니스 로직을 정의.
public interface PreferenceService {

    // 모든 취향 데이터를 카테고리별로 정렬하여 조회, @return 카테고리별로 정렬된 PreferenceResponse DTO 리스트
    List<PreferenceResponse> getAllPreferences();

    // 유저가 선택한 취향 리스트를 기반으로 연관된 재료와 조미료 추천
    PreferenceRecommendationResponse recommendRelatedKeywords(List<String> preferences);
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\preference\PreferenceServiceImpl.java
================================================================================

package com.board.one_more_project.domain.preference;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.board.one_more_project.domain.ingredient.dto.Ingredient;
import com.board.one_more_project.domain.ingredient.IngredientRepository;
import com.board.one_more_project.domain.ingredient.dto.IngredientResponse;
import com.board.one_more_project.domain.spice.Spice;
import com.board.one_more_project.domain.spice.SpiceRepository;
import com.board.one_more_project.domain.spice.SpiceResponse;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class PreferenceServiceImpl implements PreferenceService {

    private final PreferenceRepository preferenceRepository;
    private final EmbeddingModel embeddingModel;
    private final ChatModel chatModel;
    private final SpiceRepository spiceRepository;
    private final IngredientRepository ingredientRepository;

    @Override
    public List<PreferenceResponse> getAllPreferences() {
        log.info("모든 취향 데이터 조회 요청 시작");
        return preferenceRepository.findAllByOrderByCategoryAscIdAsc()
                .stream()
                .map(PreferenceResponse::from)
                .toList();
    }

    @Override
    public PreferenceRecommendationResponse recommendRelatedKeywords(List<String> preferences) {
        log.info("RAG 기반 연관 키워드 추천 시작. 입력 취향: {}", preferences);

        String userPreferences = String.join(", ", preferences);

        // [개선 1] 프롬프트 강화: 부정 명령어(Negative Constraint) 추가
        // "설명하지마", "인사하지마" 등을 명시하여 사족을 방지합니다.
        String instruction = String.format(
                "너는 데이터 추출기야. 사용자의 취향 [%s]에 가장 잘 어울리는 식재료 10개와 조미료 5개를 추천해줘.\n" +
                        "규칙 1: 서론, 결론, 부가 설명, 인사말을 절대 하지 마.\n" +
                        "규칙 2: 오직 단어만 쉼표(,)로 구분해서 나열해.\n" +
                        "규칙 3: 번호 매기기(1.)나 특수문자를 쓰지 마.\n" +
                        "예시: 돼지고기, 양파, 대파, 고추장, 간장, 소금",
                userPreferences
        );

        log.info("Exaone 모델에게 질문 전송 중...");

        // 2. Exaone 호출
        String llmResponse = chatModel.call(instruction);
        log.info("Exaone 답변 수신: {}", llmResponse);

        // [개선 2] 파싱 로직 강화 (별도 메서드로 분리)
        List<String> recommendedWords = parseLlmResponse(llmResponse);

        List<IngredientResponse> finalIngredients = new ArrayList<>();
        List<SpiceResponse> finalSpices = new ArrayList<>();

        // 4. 벡터 검색 (기존 로직 유지)
        for (String word : recommendedWords) {
            // 빈 문자열이거나 너무 긴 문장(오류)은 스킵
            if (word.isBlank() || word.length() > 20) continue;

            log.debug("추천 단어 '{}'로 DB 검색 수행", word);

            float[] vector = embeddingModel.embed(word);
            String vectorString = Arrays.toString(vector);

            List<Ingredient> ingredients = ingredientRepository.findNearestIngredients(vectorString, 1);
            if (!ingredients.isEmpty()) {
                finalIngredients.add(IngredientResponse.from(ingredients.get(0)));
            }

            List<Spice> spices = spiceRepository.findNearestSpices(vectorString, 1);
            if (!spices.isEmpty()) {
                finalSpices.add(SpiceResponse.from(spices.get(0)));
            }
        }

        // 5. 중복 제거
        List<IngredientResponse> distinctIngredients = finalIngredients.stream().distinct().collect(Collectors.toList());
        List<SpiceResponse> distinctSpices = finalSpices.stream().distinct().collect(Collectors.toList());

        log.info("최종 추천 완료: 재료 {}건, 조미료 {}건", distinctIngredients.size(), distinctSpices.size());

        return new PreferenceRecommendationResponse(distinctIngredients, distinctSpices);
    }

    /**
     * [Helper Method] LLM 응답 정제 로직
     * 특수문자 제거 및 사족 필터링을 수행합니다.
     */
    private List<String> parseLlmResponse(String response) {
        if (response == null || response.isBlank()) {
            return List.of();
        }

        // 1단계: 줄바꿈 문자를 쉼표로 치환 (혹시 엔터로 구분했을 경우 대비)
        String standardized = response.replace("\n", ",");

        // 2단계: 콜론(:)이 있다면, 콜론 뒤의 텍스트만 사용 (예: "추천 목록: 사과, 배" -> " 사과, 배")
        if (standardized.contains(":")) {
            String[] parts = standardized.split(":");
            if (parts.length > 1) {
                standardized = parts[1]; // 뒷부분만 취함
            }
        }

        // 3단계: 쉼표로 분리 후 정제
        return Arrays.stream(standardized.split(","))
                .map(String::trim)                 // 앞뒤 공백 제거
                .map(this::removeSpecialCharacters)// 특수문자(번호, 괄호 등) 제거
                .filter(word -> !word.isBlank())   // 빈 문자열 제거
                .filter(word -> word.length() >= 2)// 한 글자짜리(오타 가능성) 필터링 (선택사항)
                .toList();
    }

    // 한글, 영문, 숫자, 공백을 제외한 모든 특수문자 제거
    private String removeSpecialCharacters(String input) {
        return input.replaceAll("[^가-힣a-zA-Z0-9\\s]", "");
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\recipe\RecipeController.java
================================================================================

package com.board.one_more_project.domain.recipe;

import com.board.one_more_project.domain.ingredient.dto.IngredientAnalysisResponse;
import com.board.one_more_project.infrastructure.ai.AiClientService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Tag(name = "Recipe Flow", description = "이미지 분석 및 레시피 생성 프로세스")
@Slf4j
@RestController
@RequestMapping("/api/recipe")
public class RecipeController {

    private final AiClientService aiClientService;
    private final RecipeValidator validator;

    public RecipeController(AiClientService aiClientService, RecipeValidator validator) {
        this.aiClientService = aiClientService;
        this.validator = validator;
    }

    // 재료 이미지 or 영수증 분석 (Routing: type에 따라 다른 서비스 메서드 호출)
    @Operation(summary = "1단계: 이미지/영수증 분석 요청", description = "type 파라미터에 따라 일반 이미지 분석 또는 영수증 분석을 수행합니다.")
    @PostMapping(value = "/analyze", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public List<IngredientAnalysisResponse> analyzeImage(
            @Parameter(description = "식재료 사진 또는 영수증 파일") @RequestParam("files") List<MultipartFile> files,
            @Parameter(description = "데이터 타입 (image: 식재료, receipt: 영수증)") @RequestParam("type") String type,
            @Parameter(description = "유저 식별 ID") @RequestParam(value = "userId", defaultValue = "user_01") String userId
    ) {
        log.info("1단계 분석 요청: {}장, type={}", files.size(), type);
        validator.validateFiles(files);

        // Routing
        if ("receipt".equalsIgnoreCase(type)) { // 영수증 분석 서비스 호출 (/analyze-image-receipts)
            return aiClientService.analyzeImageReceipt(files, userId);
        } else { // 일반 식재료 이미지 분석 (/analyze-image-ingredients)
            return aiClientService.analyzeImageIngredients(files, userId);
        }
    }

    //  레시피 생성
    @Operation(summary = "2단계: 레시피 생성 요청", description = "action 값(initial, basic, more)에 따라 알맞은 레시피 생성 API를 호출합니다.")
    @PostMapping("/generate")
    public List<RecipeResponse> generateRecipe(
            @Parameter(description = "요청 데이터 (action 필드 필수)") @RequestBody RecipeGenerationRequest request
    ) {
        String action = request.action(); // DTO에서 action 값 추출

        log.info("2단계 생성 요청: userId={}, action={}", request.userId(), action);
        validator.validateIngredients(request.ingredients(), request.preferences());

        // action이 null이거나 비어있으면 에러 처리
        if (action == null || action.trim().isEmpty()) {
            throw new IllegalArgumentException("요청 타입(action)이 누락되었습니다.");
        }
        // Routing
        switch (action.toLowerCase()) {
            case "initial":
                // 최초 추천 3종 (/recipes-generate-initial)
                return aiClientService.generateRecipeInitial(request);
            case "basic":
                // 기본 재료 레시피 (/recipes-generate-basic)
                return aiClientService.generateRecipeBasic(request);
            case "more":
                // more 레시피 (/recipes-generate-more)
                return aiClientService.generateRecipeMore(request);
            case "real":
                // 만개의 레시피 (/recipes-generate-more)
                return aiClientService.generateRecipeReal(request);
            default:
                // 약속되지 않은 action 값이 오면 에러 발생
                throw new IllegalArgumentException("잘못된 요청 타입입니다: " + action);
        }
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\recipe\RecipeGenerationRequest.java
================================================================================

package com.board.one_more_project.domain.recipe;

import com.board.one_more_project.domain.ingredient.IngredientDto;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.List;

// 프론트엔드가 "레시피 요청하면 보낼 데이터셋. 기존에는 재료만 보냈지만, 조미료와 취향(리스트)까지 포함
@Schema(description = "레시피 생성 요청 데이터 (재료 + 조미료 + 취향)")
public record RecipeGenerationRequest(
        @Schema(description = "확정된 재료 리스트 (이름+수량)", requiredMode = Schema.RequiredMode.REQUIRED)
        List<IngredientDto> ingredients,

        @Schema(description = "보유한 조미료 리스트 (이름만)", example = "[\"소금\", \"후추\", \"간장\"]")
        List<String> spices,

        @Schema(description = "유저 취향 키워드 리스트", example = "[\"매콤한\", \"간단한\", \"한식\"]")
        List<String> preferences,

        @Schema(description = "유저 식별 ID", example = "user_01")
        String userId,
        // 프론트엔드가 추천(initial)을 원하는지, 기본 재료만(basic)원하는지, 응용 요리만(more)원하는지 알려주는 변수입니다.
        @Schema(description = "요청 작업 타입 (initial: 최초추천, basic: 기본재료만, more: 추가재료포함, real: 만개의레시피)", example = "real")
        String action


) {}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\recipe\RecipeResponse.java
================================================================================

package com.board.one_more_project.domain.recipe;

import com.board.one_more_project.domain.ingredient.IngredientDto;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.List;

// 파이썬의 레시피 추천 결과(...추천해줘.txt) 구조에 맞춤.
// ingredients -> IngredientDto List, more(추가 재료) 필드 추가.
@Schema(description = "AI 추천 레시피 상세 정보")
public record RecipeResponse(
        @Schema(description = "요리 제목", example = "매콤 돼지고기 김치 볶음밥")
        String title,

        @Schema(description = "한 줄 요약", example = "돼지고기와 김치의 환상적인 조화!")
        String summary,

        @Schema(description = "필요한 재료 리스트")
        List<IngredientDto> ingredients,

        @Schema(description = "추가로 필요한 재료 (응용 레시피인 경우)", nullable = true)
        List<IngredientDto> more,

        @Schema(description = "조리 순서", example = "[\"1. 고기를 볶는다\", \"2. 김치를 넣는다\"]")
        List<String> recipe,

        @Schema(description = "요리 팁", example = "[\"신김치를 쓰면 설탕을 넣으세요\"]")
        List<String> tip,

        // 파이썬 응답 예시에 image, reference가 있어서 추가해둠 (없을 수도 있음)
        // nullable = Json역직렬화 할 때, 데이터가 없으면 null로 표시할 수 있다는 뜻
        @Schema(description = "참고 이미지 URL", nullable = true)
        String image,

        @Schema(description = "참고 레시피 링크", nullable = true)
        String reference
) {}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\recipe\RecipeValidator.java
================================================================================

package com.board.one_more_project.domain.recipe;

import com.board.one_more_project.domain.ingredient.IngredientDto;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;
import java.util.List;

@Component
public class RecipeValidator {

    // 1단계: 이미지 분석 요청 검증
    public void validateFiles(List<MultipartFile> files) {
        // 1. 파일이 아예 없는지 확인
        if (files == null || files.isEmpty()) {
            throw new IllegalArgumentException("업로드된 파일이 없습니다.");
        }

        // 2. 파이썬 서버 안정성을 위해 최대 3장으로 제한
        if (files.size() > 3) {
            throw new IllegalArgumentException("사진은 최대 3장까지만 업로드 가능합니다.");
        }
    }

    // 2단계: 레시피 생성 요청 검증
    public void validateIngredients(List<IngredientDto> ingredients, List<String> preferences) {
        if (ingredients == null || ingredients.isEmpty()) {
            throw new IllegalArgumentException("입력된 재료가 없습니다.");
        }

        // 재료 이름이 비어있는지 확인
        boolean hasValidIngredient = ingredients.stream()
                .anyMatch(item -> item.ingredient() != null && !item.ingredient().trim().isEmpty());

        if (!hasValidIngredient) {
            throw new IllegalArgumentException("유효한 재료 이름이 하나도 없습니다.");
        }
        checkPreferenceLength(preferences);
    }

    // 공통: 취향 키워드 개수 제한
    private void checkPreferenceLength(List<String> preferences) {
        if (preferences != null && preferences.size() >= 100) {
            throw new IllegalArgumentException("요리 취향 키워드는 100개 이내로 선택해주세요.");
        }
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\spice\Spice.java
================================================================================

package com.board.one_more_project.domain.spice;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import java.time.OffsetDateTime;

@Entity // JPA가 관리하는 엔티티임을 선언 (ORM 매핑 대상)
@Table(name = "spices") // 매핑할 DB 테이블 명시
@Getter // Lombok: Getter 메서드 생성 (불변성 확보를 위해 Setter는 지양)
@NoArgsConstructor // JPA 스펙 준수를 위한 기본 생성자 (Protected/Public)
public class Spice {

    @Id // Primary Key 매핑
    @GeneratedValue(strategy = GenerationType.IDENTITY) // PostgreSQL SERIAL 전략 사용
    private Long id;

    @Column(nullable = false, unique = true) // Not Null, Unique 제약조건 설정
    private String name;

    @Column(name = "created_at")
    private OffsetDateTime createdAt;

    // 엔티티 생명주기 이벤트: 영속화(Persist) 전 실행
    @PrePersist
    public void onPrePersist() {
        this.createdAt = OffsetDateTime.now();
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\spice\SpiceController.java
================================================================================

package com.board.one_more_project.domain.spice;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@Tag(name = "Master Data", description = "취향, 재료, 조미료 등 마스터 데이터 조회")
@Slf4j
@RestController
@RequestMapping("/api/spices")
@RequiredArgsConstructor
public class SpiceController {

    private final SpiceService spiceService;

    @Operation(summary = "조미료 목록 조회", description = "모든 조미료 목록을 이름순으로 반환합니다.")
    @GetMapping
    public ResponseEntity<List<SpiceResponse>> getAllSpices() {
        log.info("GET /api/spices 요청 수신");
        return ResponseEntity.ok(spiceService.getAllSpices());
    }

    @Operation(summary = "조미료 검색 (AI 유사도)", description = "키워드와 유사한 조미료를 검색합니다.")
    @GetMapping("/search")
    public ResponseEntity<List<SpiceResponse>> searchSpices(@RequestParam("q") String keyword) {
        log.info("GET /api/spices/search?q={} 요청 수신", keyword);
        return ResponseEntity.ok(spiceService.searchSpices(keyword));
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\spice\SpiceRepository.java
================================================================================

package com.board.one_more_project.domain.spice;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

public interface SpiceRepository extends JpaRepository<Spice, Long> {

    List<Spice> findAllByOrderByNameAsc();

    // 테이블명을 spices로 정확히 수정 및 반환 타입 int 변경
    @Modifying(clearAutomatically = true)
    @Transactional
    @Query(value = "UPDATE spices SET embedding = cast(:embedding as vector) WHERE id = :id", nativeQuery = true)
    int updateEmbedding(@Param("id") Long id, @Param("embedding") String embedding);

    @Query(value = "SELECT * FROM spices " +
            "ORDER BY embedding <=> cast(:queryVector as vector) " +
            "LIMIT :limit", nativeQuery = true)
    List<Spice> findNearestSpices(@Param("queryVector") String queryVector, @Param("limit") int limit);
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\spice\SpiceResponse.java
================================================================================

package com.board.one_more_project.domain.spice;

import io.swagger.v3.oas.annotations.media.Schema;

// Java 17 record: 불변 데이터 객체(DTO)를 위한 보일러플레이트 코드 감소
@Schema(description = "조미료 마스터 데이터")
public record SpiceResponse(
        @Schema(description = "조미료 고유 ID", example = "1")
        Long id,

        @Schema(description = "조미료 이름", example = "소금")
        String name
) {
    /**
     * [Factory Method]
     * 엔티티를 DTO로 변환하는 정적 팩토리 메서드입니다.
     * 스트림 API의 map 메서드에서 메서드 레퍼런스(SpiceResponse::from)로 사용하기 적합합니다.
     */
    public static SpiceResponse from(Spice entity) {
        return new SpiceResponse(
                entity.getId(),
                entity.getName()
        );
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\spice\SpiceService.java
================================================================================

package com.board.one_more_project.domain.spice;

import java.util.List;

/**
 * [Service Interface]
 * 조미료 도메인의 비즈니스 로직 명세(Contract)를 정의합니다.
 * 이를 통해 OCP(Open-Closed Principle)를 준수하며 구현체를 교체할 수 있는 유연성을 확보합니다.
 */
public interface SpiceService {

    /**
     * 등록된 모든 조미료 데이터를 조회합니다.
     * @return DTO로 변환된 조미료 리스트
     */
    List<SpiceResponse> getAllSpices();

    List<SpiceResponse> searchSpices(String keyword);

}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\domain\spice\SpiceServiceImpl.java
================================================================================

package com.board.one_more_project.domain.spice;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.embedding.EmbeddingModel; // Spring AI 인터페이스
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class SpiceServiceImpl implements SpiceService {

    private final SpiceRepository spiceRepository;
    private final EmbeddingModel embeddingModel; // Ollama 구현체가 자동 주입됨

    @Override
    public List<SpiceResponse> getAllSpices() {
        log.info("모든 조미료 데이터 조회 요청");
        return spiceRepository.findAllByOrderByNameAsc()
                .stream()
                .map(SpiceResponse::from)
                .toList();
    }

    /**
     * [의미론적 검색]
     * Ollama를 통해 검색어를 벡터화하고 DB 유사도 쿼리를 실행합니다.
     */
    @Override
    public List<SpiceResponse> searchSpices(String keyword) {
        log.info("조미료 검색 시작 (Ollama): {}", keyword);

        // 1. 검색어 임베딩 생성
        float[] vector = embeddingModel.embed(keyword);

        // 2. pgvector 유사도 검색 수행
        List<Spice> results = spiceRepository.findNearestSpices(Arrays.toString(vector), 10);

        // 3. DTO 변환 후 반환
        return results.stream()
                .map(SpiceResponse::from)
                .toList();
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\global\config\WebConfig.java
================================================================================

package com.board.one_more_project.global.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // 모든 경로에 대해
                .allowedOrigins("*") // 모든 출처(휴대폰, 웹, 다른 서버) 허용
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // 모든 HTTP 메서드 허용
                .allowedHeaders("*"); // 모든 헤더 허용
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\global\error\GlobalExceptionHandler.java
================================================================================

package com.board.one_more_project.global.error;

import com.board.one_more_project.domain.recipe.RecipeResponse;
import com.board.one_more_project.global.error.exception.AiServerException; // import 추가
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.Collections;
import java.util.List;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 기존의 검증 에러 처리 (400 Bad Request)
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<RecipeResponse> handleValidationException(IllegalArgumentException e) {
        log.warn("검증 실패(User Input Error): {}", e.getMessage());
        RecipeResponse errorResponse = createErrorResponse("입력 오류 발생", e.getMessage());
        return ResponseEntity.badRequest().body(errorResponse);
    }

    // [추가됨] AI 서버 통신 에러 처리 (503 Service Unavailable)
    @ExceptionHandler(AiServerException.class)
    public ResponseEntity<RecipeResponse> handleAiServerException(AiServerException e) {
        log.error("AI 서비스 장애: {}", e.getMessage());

        // 프론트엔드가 깨지지 않도록, 에러 메시지를 담은 객체 생성
        RecipeResponse errorResponse = createErrorResponse(
                "서비스 일시 지연",
                e.getMessage() // "현재 AI 서버에 연결할 수 없습니다..." 등의 메시지가 들어감
        );

        // 503 상태 코드로 반환 -> 클라이언트가 재시도 로직을 짤 수 있음
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(errorResponse);
    }

    // 에러 응답 생성 헬퍼 메서드 (중복 제거용)
    private RecipeResponse createErrorResponse(String title, String message) {
        return new RecipeResponse(
                title,                          // title
                message,                        // summary (에러 상세 내용)
                Collections.emptyList(),        // ingredients
                null,                           // more
                List.of("잠시 후 다시 시도해주세요."), // recipe
                List.of("서버 점검 중일 수 있습니다."), // tip
                null,                           // image
                null                            // reference
        );
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\global\error\exception\AiServerException.java
================================================================================

package com.board.one_more_project.global.error.exception;

// AI 서버 통신 장애 시 발생시킬 전용 예외
public class AiServerException extends RuntimeException {
    public AiServerException(String message) {
        super(message);
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\infrastructure\ai\AiClientService.java
================================================================================

package com.board.one_more_project.infrastructure.ai;

import com.board.one_more_project.domain.ingredient.dto.IngredientAnalysisResponse;
import com.board.one_more_project.domain.recipe.RecipeGenerationRequest;
import com.board.one_more_project.domain.recipe.RecipeResponse;
import org.springframework.web.multipart.MultipartFile;
import java.util.List;

/**
 * [AI 통신 서비스 인터페이스]
 * 컨트롤러와 실제 구현체(Real/Mock) 사이의 연결 고리입니다.
 * 파이썬 서버의 응답 구조가 { "result": [...] } 리스트 형태이므로,
 * 반환 타입도 모두 List<> 형태로 변경했습니다.
 */
public interface AiClientService {
    // 재료 사진 분석
    List<IngredientAnalysisResponse> analyzeImageIngredients(List<MultipartFile> files, String userId);

    // 영수증 사진 분석
    List<IngredientAnalysisResponse> analyzeImageReceipt(List<MultipartFile> files, String userId);

    // 최초 레시피 추천 생성 (/recipes-generate-initial)
    List<RecipeResponse> generateRecipeInitial(RecipeGenerationRequest request);

    // 기본 재료 레시피만 생성(/recipes-generate-basic)
    List<RecipeResponse> generateRecipeBasic(RecipeGenerationRequest request);

    // 추가 재료(응용) 레시피만 생성 (/recipes-generate-more)
    List<RecipeResponse> generateRecipeMore(RecipeGenerationRequest request);

    // 만개의 레시피 기반 추천 (/recipes-generate-real)
    List<RecipeResponse> generateRecipeReal(RecipeGenerationRequest request);


}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\infrastructure\ai\MockAiClientService.java
================================================================================

package com.board.one_more_project.infrastructure.ai;

import com.board.one_more_project.domain.ingredient.dto.IngredientAnalysisResponse;
import com.board.one_more_project.domain.ingredient.IngredientDto;
import com.board.one_more_project.domain.recipe.RecipeGenerationRequest;
import com.board.one_more_project.domain.recipe.RecipeResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Slf4j
@Service
@Profile("dev")
public class MockAiClientService implements AiClientService {

    // 1-1. 일반 이미지 분석 Mock
    @Override
    public List<IngredientAnalysisResponse> analyzeImageIngredients(List<MultipartFile> files, String userId) {
        log.info("[Mock] 일반 이미지 분석. User: {}", userId);
        return List.of(new IngredientAnalysisResponse(0, List.of(new IngredientDto("목살", "300g"))));
    }

    // 1-2. 영수증 분석 Mock
    @Override
    public List<IngredientAnalysisResponse> analyzeImageReceipt(List<MultipartFile> files, String userId) {
        log.info("[Mock] 영수증 분석. User: {}", userId);
        return List.of(new IngredientAnalysisResponse(0, List.of(new IngredientDto("영수증_두부", "1모"))));
    }

    // 2-1. 최초 추천 Mock
    @Override
    public List<RecipeResponse> generateRecipeInitial(RecipeGenerationRequest request) {
        log.info("[Mock] 최초 레시피 추천. User: {}", request.userId());
        return List.of(new RecipeResponse("최초 추천 요리", "맛있습니다", request.ingredients(), null, List.of("요리하세요"), List.of("팁"), null, null));
    }

    // 2-2. 기본 레시피 Mock
    @Override
    public List<RecipeResponse> generateRecipeBasic(RecipeGenerationRequest request) {
        log.info("[Mock] 기본 레시피 생성. User: {}", request.userId());
        return List.of(new RecipeResponse("기본 재료 요리", "간단합니다", request.ingredients(), null, List.of("볶으세요"), List.of("팁"), null, null));
    }

    // 2-3. 응용 레시피 Mock
    @Override
    public List<RecipeResponse> generateRecipeMore(RecipeGenerationRequest request) {
        log.info("[Mock] 응용 레시피 생성. User: {}", request.userId());
        return List.of(new RecipeResponse("응용 요리", "특별합니다", request.ingredients(), List.of(new IngredientDto("치즈", "1장")), List.of("치즈를 넣으세요"), List.of("팁"), null, null));
    }

    @Override
    public List<RecipeResponse> generateRecipeReal(RecipeGenerationRequest request) {
        return List.of(new RecipeResponse("만개의 레시피 요리", "역시 맛있어요", request.ingredients(), List.of(new IngredientDto("만개의 레시피 한포기", "한포기")), List.of("레시피를 넣으세요"), List.of("팁"), null, null));
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\infrastructure\ai\RealAiClientService.java
================================================================================

package com.board.one_more_project.infrastructure.ai;
import com.board.one_more_project.domain.ingredient.dto.IngredientAnalysisResponse;
import com.board.one_more_project.domain.recipe.RecipeGenerationRequest;
import com.board.one_more_project.domain.recipe.RecipeResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import com.board.one_more_project.global.error.exception.AiServerException; // 1단계에서 만든 예외 import
import org.springframework.web.client.ResourceAccessException; // 중요: 연결 실패 예외



import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Service
@Profile("prod") // 운영(prod) 환경에서만 작동
public class RealAiClientService implements AiClientService {

    private final RestTemplate restTemplate;
    private final String aiServerUrl;

    private record PythonResponseWrapper<genericType>(List<genericType> result) {}

    // 반복되는 파이썬의 응답 구조 { "result": [...] }를 받기 위한 Wrapper class
    public RealAiClientService(@Value("${ai-server.url}") String aiServerUrl) {
        this.aiServerUrl = aiServerUrl;

        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();

        factory.setConnectTimeout(5000);
        factory.setReadTimeout(120000);

        this.restTemplate = new RestTemplate(factory);
        log.info("[prod] RealAiClientService가 초기화되었습니다. Target URL: {}", aiServerUrl);
    }
    //region 이미지 분석 함수
    @Override
    public List<IngredientAnalysisResponse> analyzeImageReceipt(List<MultipartFile> files, String userId) {
        return sendImageRequest("/analyze-image-receipts", files, userId);
    }

    @Override
    public List<IngredientAnalysisResponse> analyzeImageIngredients(List<MultipartFile> files, String userId) {
        return sendImageRequest("/analyze-image-ingredients", files, userId);
    }

    private List<IngredientAnalysisResponse> sendImageRequest(String uri, List<MultipartFile> files, String userId) {
        log.info("[prod] 이미지 분석 요청: URI={}, Count={}, User={}", uri, files.size(), userId);

        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        if (files != null) {
            for (MultipartFile file : files) {
                body.add("files", file.getResource());
            }
        }
        body.add("userId", userId);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);
        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<PythonResponseWrapper<IngredientAnalysisResponse>> responseEntity =
                    restTemplate.exchange(
                            aiServerUrl + uri,
                            HttpMethod.POST,
                            requestEntity,
                            new ParameterizedTypeReference<PythonResponseWrapper<IngredientAnalysisResponse>>() {}
                    );
            PythonResponseWrapper<IngredientAnalysisResponse> response = responseEntity.getBody();
            return response != null ? response.result() : Collections.emptyList();

        } catch (ResourceAccessException e) {
            // 파이썬 서버가 꺼져있거나 네트워크가 끊긴 경우 (Timeout 포함)
            log.error("AI 서버 연결 실패 (URI: {}): {}", uri, e.getMessage());
            throw new AiServerException("현재 AI 분석 서버에 연결할 수 없습니다. 잠시 후 다시 시도해주세요.");
        } catch (RestClientException e) {
            // 파이썬 서버가 400, 500 에러를 뱉은 경우
            log.error("AI 서버 응답 오류 (URI: {}): {}", uri, e.getMessage());
            throw new AiServerException("AI 분석 중 오류가 발생했습니다. 관리자에게 문의하세요.");
        } catch (Exception e) {
            // 그 외 알 수 없는 오류
            log.error("알 수 없는 오류 (URI: {}): {}", uri, e.getMessage());
            throw new AiServerException("서비스 처리 중 예기치 않은 오류가 발생했습니다.");
        }
    }
    //endregion

    //region 레시피 생성 함수
    @Override
    public List<RecipeResponse> generateRecipeInitial(RecipeGenerationRequest request) {
        return sendRecipeRequest("/recipes-generate-initial", request);
    }

    @Override
    public List<RecipeResponse> generateRecipeBasic(RecipeGenerationRequest request) {
        return sendRecipeRequest("/recipes-generate-basic", request);
    }

    @Override
    public List<RecipeResponse> generateRecipeMore(RecipeGenerationRequest request) {
        return sendRecipeRequest("/recipes-generate-more", request);
    }

    @Override
    public List<RecipeResponse> generateRecipeReal(RecipeGenerationRequest request) {
        return sendRecipeRequest("/recipes-generate-real", request);
    }

    private List<RecipeResponse> sendRecipeRequest(String uri, RecipeGenerationRequest request) {
        log.info("[prod] 레시피 생성 요청 전송: URI={}, User={}", uri, request.userId());

        Map<String, Object> body = new HashMap<>();
        body.put("userId", request.userId());
        body.put("ingredients", request.ingredients());
        body.put("spices", request.spices());
        body.put("preferences", request.preferences());
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<PythonResponseWrapper<RecipeResponse>> responseEntity =
                    restTemplate.exchange(
                            aiServerUrl + uri,
                            HttpMethod.POST,
                            requestEntity,
                            new ParameterizedTypeReference<PythonResponseWrapper<RecipeResponse>>() {}
                    );

            PythonResponseWrapper<RecipeResponse> response = responseEntity.getBody();
            return response != null ? response.result() : Collections.emptyList();

        } catch (ResourceAccessException e) {
            log.error("AI 서버 연결 실패 (URI: {}): {}", uri, e.getMessage());
            throw new AiServerException("현재 AI 요리사 서버가 응답하지 않습니다. (Connection Error)");
        } catch (RestClientException e) {
            log.error("AI 서버 응답 오류 (URI: {}): {}", uri, e.getMessage());
            throw new AiServerException("레시피 생성 중 AI 서버 오류가 발생했습니다.");
        } catch (Exception e) {
            log.error("알 수 없는 오류 (URI: {}): {}", uri, e.getMessage());
            throw new AiServerException("서비스 처리 중 예기치 않은 오류가 발생했습니다.");
        }
    }
    //endregion
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\infrastructure\ai\migration\MigrationController.java
================================================================================

package com.board.one_more_project.infrastructure.ai.migration;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping("/api/admin/migration")
@RequiredArgsConstructor
public class MigrationController {

    private final VectorMigrationService migrationService;

    // application.properties에서 관리자 키를 가져옴
    @Value("${admin.secret-key:default-unsafe-key}")
    private String adminSecretKey;

    @Operation(summary = "데이터 임베딩 초기화 (관리자 전용)",
            description = "헤더에 정확한 X-ADMIN-KEY가 있어야만 실행됩니다.")
    @PostMapping("/vectors")
    public ResponseEntity<String> runMigration(
            @Parameter(description = "관리자 비밀키", required = true)
            @RequestHeader("X-ADMIN-KEY") String requestKey
    ) {
        // 1. 보안 체크: 헤더로 들어온 키와 설정 파일의 키가 일치하는지 확인
        if (!adminSecretKey.equals(requestKey)) {
            log.warn("마이그레이션 접근 거부: 잘못된 키 ({})", requestKey);
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("접근 권한이 없습니다. (Invalid Admin Key)");
        }

        log.info("관리자 인증 성공. 벡터 마이그레이션을 시작합니다.");

        // 2. 작업 수행 (비동기로 처리하면 더 좋지만, 일단 동기 처리 유지)
        try {
            migrationService.migrateAll();
            return ResponseEntity.ok("마이그레이션이 성공적으로 완료되었습니다.");
        } catch (Exception e) {
            log.error("마이그레이션 실패", e);
            return ResponseEntity.internalServerError()
                    .body("마이그레이션 중 오류 발생: " + e.getMessage());
        }
    }
}

================================================================================
 FILE: backend-spring\src\main\java\com\board\one_more_project\infrastructure\ai\migration\VectorMigrationService.java
================================================================================

package com.board.one_more_project.infrastructure.ai.migration;

import com.board.one_more_project.domain.ingredient.dto.Ingredient;
import com.board.one_more_project.domain.ingredient.IngredientRepository;
import com.board.one_more_project.domain.spice.Spice;
import com.board.one_more_project.domain.spice.SpiceRepository;
import com.board.one_more_project.domain.preference.Preference;
import com.board.one_more_project.domain.preference.PreferenceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class VectorMigrationService {

    private final IngredientRepository ingredientRepository;
    private final SpiceRepository spiceRepository;
    private final PreferenceRepository preferenceRepository;
    private final EmbeddingModel embeddingModel;

    /**
     * [전체 마이그레이션]
     * @Transactional을 추가하여 전체 프로세스의 데이터 일관성을 보장합니다.
     */
    @Transactional
    public void migrateAll() {
        log.info("=== Ollama 벡터 마이그레이션 시작 ===");

        // 1. 재료 마이그레이션
        List<Ingredient> ingredients = ingredientRepository.findAll();
        for (Ingredient item : ingredients) {
            // Ollama는 float[]를 반환함
            float[] vector = embeddingModel.embed(item.getName());
            String vectorString = Arrays.toString(vector);
            ingredientRepository.updateEmbedding(item.getId(), vectorString);
        }
        log.info("재료 마이그레이션 완료 ({}건)", ingredients.size());

        // 2. 조미료 마이그레이션
        List<Spice> spices = spiceRepository.findAll();
        for (Spice item : spices) {
            float[] vector = embeddingModel.embed(item.getName());
            String vectorString = Arrays.toString(vector);
            spiceRepository.updateEmbedding(item.getId(), vectorString);
        }
        log.info("조미료 마이그레이션 완료 ({}건)", spices.size());

        // 3. 취향 마이그레이션
        List<Preference> preferences = preferenceRepository.findAll();
        for (Preference item : preferences) {
            float[] vector = embeddingModel.embed(item.getName());
            String vectorString = Arrays.toString(vector);
            preferenceRepository.updateEmbedding(item.getId(), vectorString);
        }
        log.info("취향 마이그레이션 완료 ({}건)", preferences.size());

        log.info("=== 모든 벡터 마이그레이션 완료 ===");
    }
}

================================================================================
 FILE: backend-spring\src\main\resources\application.properties
================================================================================

# Server Configuration
server.port=8080
spring.profiles.active=${APP_ENV:dev}

# Servlet Multipart
spring.servlet.multipart.max-file-size=15MB
spring.servlet.multipart.max-request-size=76MB

# Database (PostgreSQL)
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:5432/one-more-db
spring.datasource.username=${DB_USER:postgres}
spring.datasource.password=${DB_PW:1234}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA / Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# External AI Server (FastAPI - receipt/image analyze)
ai-server.url=${AI_SERVER_URL:http://192.168.22.54:8000}

# Swagger (SpringDoc OpenAPI)
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.groups-order=DESC
springdoc.swagger-ui.operations-sorter=method
springdoc.api-docs.path=/api-docs

# Ollama Base URL
spring.ai.ollama.base-url=${OLLAMA_URL:http://127.0.0.1:11434}
# embedding model
spring.ai.ollama.embedding.options.model=bge-m3
# embedding api secure
admin.secret-key=${ADMIN_SECRET_KEY:1234}
# LLM chat model
spring.ai.ollama.chat.options.model=exaone3.5:2.4b




================================================================================
 FILE: backend-spring\src\test\java\com\board\one_more_project\OneMoreProjectApplicationTests.java
================================================================================

package com.board.one_more_project;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class OneMoreProjectApplicationTests {

    @Test
    void contextLoads() {
    }

}

